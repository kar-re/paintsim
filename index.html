<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>DSek painting simulator</title>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #808080;
				font-family: Monospace;
				font-size: 13px;
				text-align: center;

				background-color: #ffffff;
				margin: 0px;
				overflow: hidden;
			}

			#container {
				cursor: none;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
				cursor: auto;
			}
		</style>
	</head>
	<body>
		<div id="container"></div>
		<div id="info"><a href="https://github.com/kar-re/paintsim" target="_blank" rel="noopener">DSek Kiosken simulator</a> <p id="sek"></p> <br>Vänsterklick för att måla | Högerklick för att rotera</div>
		<script src="content/three.js"></script>
		<script src="content/OBJLoader.js"></script>
		<script src="content/OrbitControls.js"></script>
		<script src="https://unpkg.com/three@0.105.0/examples/js/loaders/RGBELoader.js"></script>
		<script src="https://unpkg.com/three@0.105.0/examples/js/pmrem/PMREMGenerator.js"></script>
		<script src="https://unpkg.com/three@0.105.0/examples/js/pmrem/PMREMCubeUVPacker.js"></script>
		<script src="https://unpkg.com/three@0.105.0/examples/js/loaders/EquirectangularToCubeGenerator.js"></script>
		<script src="content/TexturePainter.js"></script>
		<script>
			var width = window.innerWidth;
			var height = window.innerHeight;

			var container, controls;
			var renderer, camera, scene;
			var painter;

			function init() {

				var container = document.getElementById( "container" );

				renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( width, height );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1.1;
				renderer.outputEncoding = THREE.sRGBEncoding;
				container.appendChild( renderer.domElement );

				
				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xeeeeee );

				camera = new THREE.PerspectiveCamera( 45, width / height, 1, 1000 );
				camera.position.z = 100;
				camera.lookAt( scene.position );
				
				


						

				controls = new THREE.OrbitControls( camera );
				controls.enableZoom = true;
				controls.enablePan = false;
				controls.mouseButtons.LEFT = THREE.MOUSE.RIGHT;
				controls.mouseButtons.RIGHT = THREE.MOUSE.LEFT;
				controls.update();

				// const ambientLight = new THREE.AmbientLight( 0xffffff, 0.44 );
				// scene.add( ambientLight );

				//  const pointLight = new THREE.PointLight( 0xffffff, -0.62 );
				
				//  camera.add( pointLight );
				//  scene.add( camera );

				// Plane model.
				var planeTexture = new THREE.Texture( undefined, THREE.UVMapping, THREE.MirroredRepeatWrapping, THREE.MirroredRepeatWrapping );
				planeTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();

				// MeshPhysicalMaterial
				var planeMaterial = new THREE.MeshPhysicalMaterial( { map: planeTexture, roughness: 0.85, metalness: 0.01, normalScale : new THREE.Vector2( 0.4, 0.4 ) } );	
				console.log();
				// instantiate a loader
				const loaderTex = new THREE.TextureLoader();
				
				// load a resource
				loaderTex.load(
					// resource URL
					'content/ao.jpg',

					// onLoad callback
					function ( texture ) {
						// in this example we create the material when the texture is loaded
						planeMaterial.roughnessMap = texture;
					},

					// onProgress callback currently not supported
					undefined,

					// onError callback
					function ( err ) {
						console.error( 'An error happened.' );
					}
				);
				const loaderTexB = new THREE.TextureLoader();
				loaderTexB.load(
					// resource URL
					'content/normal.jpg',

					// onLoad callback
					function ( texture ) {
						// in this example we create the material when the texture is loaded
						planeMaterial.normalMap = texture;
					},

					// onProgress callback currently not supported
					undefined,

					// onError callback
					function ( err ) {
						console.error( 'An error happened.' );
					}
				);

				
				var planeGeometry = new THREE.TorusGeometry( 20, 7, 32, 128 );

				 var mesh = new THREE.Mesh( planeGeometry, planeMaterial );
				 //mesh.position.y = -5;
				 //mesh.updateMatrix();
				// scene.add( mesh );
				// scene.add( planeGeometry );
				 painter = new THREE.TexturePainter( renderer, camera, mesh);
				const loader = new THREE.OBJLoader();
				
			
				var envLoader = new THREE.RGBELoader().setPath( 'content/' ).setType( THREE.UnsignedByteType )
				.load( 'venice_sunset_2k.hdr', function ( texture ) {

					texture.encoding = THREE.RGBEEncoding;
					texture.minFilter = THREE.LinearFilter;
					texture.magFilter = THREE.LinearFilter;
					texture.generateMipmaps = true;
					texture.flipY = true;
					texture.anisotropy = renderer.capabilities.getMaxAnisotropy();

					var cubeGenerator = new THREE.EquirectangularToCubeGenerator( texture, { resolution: 1024 } );
					cubeGenerator.update( renderer );

					var background = cubeGenerator.renderTarget;

					var pmremGenerator = new THREE.PMREMGenerator( cubeGenerator.renderTarget.texture );
					pmremGenerator.update( renderer );

					var pmremCubeUVPacker = new THREE.PMREMCubeUVPacker( pmremGenerator.cubeLods );
					pmremCubeUVPacker.update( renderer );

					envmap = pmremCubeUVPacker.CubeUVRenderTarget.texture;
					scene.background = background;
					scene.environment = envmap;
					planeMaterial.envMap = envmap;

						// load a resource
				loader.load(
					// resource URL
					'content/kiosk.obj',
					// called when resource is loaded
					function ( object ) {
						var mesha;
						object.traverse( function( child ) {
						if ( child instanceof THREE.Mesh ) {
							// console.log("Hej!");
							child.material = planeMaterial;
							child.material.envMap = envmap;
							// const texture = new THREE.TextureLoader().load(child.materal.map.image);
							// var roughness = child.material.map.a;
							console.log(child.material.map);
							mesha = child;
							var geometry = new THREE.Geometry().fromBufferGeometry( child.geometry );
							geometry.computeFaceNormals();
							geometry.mergeVertices();
							geometry.computeVertexNormals();
							child.geometry = geometry;
						}
					} );
					
						
						scene.add( mesha );
						mesha.updateMatrix();

						painter.mesh = mesha;
						
						

					},
					// called when loading is in progresses
					function ( xhr ) {

						// console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

					},
					// called when loading has errors
					function ( error ) {

						console.log( 'An error happened' );

					}
				);


					texture.dispose();
					pmremGenerator.dispose();
					pmremCubeUVPacker.dispose();
					
						render();
					} );
				
				
				


				

				window.addEventListener( 'resize', onWindowResize, false );

			}


			function onWindowResize() {

				var aspect = window.innerWidth / window.innerHeight;

				camera.aspect = aspect;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

				painter.resize();

			}

			function render() {

				requestAnimationFrame( render );

				controls.update();

				renderer.autoClear = true;

				renderer.render( scene, camera );

				// needs to be after scene is rendered.
				painter.update();
			}

			init();
			render();

		</script>
	

</body></html>